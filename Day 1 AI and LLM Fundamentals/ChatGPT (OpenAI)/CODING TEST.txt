CODING TEST:
Prompt:
"Създай PHP функция за валидиране на български ЕГН. Обясни логиката стъпка по стъпка."

Response:

# PHP функция за валидиране на българско ЕГН (и кратко парсване)

Ето една ясна и надеждна реализация плюс пример и подробно обяснение стъпка по стъпка.

```php
<?php
declare(strict_types=1);

/**
 * Проверява дали дадено ЕГН е валидно.
 *
 * @param string $egn 10-цифрен низ
 * @return bool true ако е валидно, false в противен случай
 */
function validateEGN(string $egn): bool {
    $egn = trim($egn);

    // 1) Дължина и само цифри
    if (!preg_match('/^\d{10}$/', $egn)) {
        return false;
    }

    // 2) Разделяне на части
    $yy = intval(substr($egn, 0, 2));
    $mm = intval(substr($egn, 2, 2));
    $dd = intval(substr($egn, 4, 2));

    // 3) Определяне на век/реален месец
    if ($mm >= 1 && $mm <= 12) {
        $year = 1900 + $yy;
        $month = $mm;
    } elseif ($mm >= 21 && $mm <= 32) {
        $year = 1800 + $yy;
        $month = $mm - 20;
    } elseif ($mm >= 41 && $mm <= 52) {
        $year = 2000 + $yy;
        $month = $mm - 40;
    } else {
        return false; // некоректен месец (не попада в никой от трите диапазона)
    }

    // 4) Проверка дали датата е валидна
    if (!checkdate($month, $dd, $year)) {
        return false;
    }

    // 5) Проверка на контролна цифра
    $weights = [2, 4, 8, 5, 10, 9, 7, 3, 6];
    $sum = 0;
    for ($i = 0; $i < 9; $i++) {
        $sum += intval($egn[$i]) * $weights[$i];
    }
    $remainder = $sum % 11;
    $checksum = ($remainder === 10) ? 0 : $remainder;

    return intval($egn[9]) === $checksum;
}

/**
 * Парсва валидно ЕГН и връща масив с информация (или false ако ЕГН е невалидно).
 *
 * @param string $egn
 * @return array|false
 */
function parseEGN(string $egn) {
    if (!validateEGN($egn)) {
        return false;
    }

    $yy = intval(substr($egn, 0, 2));
    $mm = intval(substr($egn, 2, 2));
    $dd = intval(substr($egn, 4, 2));

    if ($mm >= 1 && $mm <= 12) {
        $year = 1900 + $yy;
        $month = $mm;
    } elseif ($mm >= 21 && $mm <= 32) {
        $year = 1800 + $yy;
        $month = $mm - 20;
    } else { // 41..52
        $year = 2000 + $yy;
        $month = $mm - 40;
    }

    $birthdate = sprintf('%04d-%02d-%02d', $year, $month, $dd);

    // Пол: 9-та цифра (индекс 8) — нечетна = мъж, четна = жена
    $genderDigit = intval($egn[8]);
    $gender = ($genderDigit % 2 === 0) ? 'F' : 'M';

    return [
        'birthdate' => $birthdate,
        'gender'    => $gender,
        'serial'    => substr($egn, 6, 3),
        'checksum'  => intval($egn[9]),
    ];
}

// Примери
$example = '8503150012';
var_dump(validateEGN($example)); // очаква се true
var_dump(parseEGN($example));    // очаква се array с дата 1985-03-15 и пол M/F в зависимост от 9-та цифра
```

---

# Обяснение стъпка по стъпка (логика)

1. **Формат**
   ЕГН е низ от точно 10 цифри: `YYMMDDXXXC`

   * `YY` — последните две цифри от годината на раждане
   * `MM` — месец (но с кодиране, виж по-надолу)
   * `DD` — ден
   * `XXX` — трицифрен сериен номер / код на населено място (последната от тези три определя пола)
   * `C` — контролна цифра (checksum)

2. **Месец/век (специално кодиране)**

   * Ако `MM` е 01–12 → рождената година е 1900 + `YY`.
   * Ако `MM` е 21–32 → рождената година е 1800 + `YY`, а реалният месец е `MM - 20`.
   * Ако `MM` е 41–52 → рождената година е 2000 + `YY`, а реалният месец е `MM - 40`.
     Това позволява да се кодират хора родени в 1800-, 1900- и 2000-те.

3. **Проверка на датата**
   След като определим реална година, месец и ден, използваме `checkdate(month, day, year)` (PHP) за да сме сигурни, че датата е валидна (включва високосни години, числа за месеци/дни и т.н.).

4. **Изчисляване на контролна цифра**
   Контролната цифра `C` се изчислява така:

   * Умножаваме първите 9 цифри със съответните тегла: `[2,4,8,5,10,9,7,3,6]`.
   * Сумираме получените произведения.
   * Правим остатък от делене на сумата на 11 (`sum % 11`).
   * Ако остатъкът е 10 → контролна цифра = 0; иначе контролна цифра = остатък.

5. **Пол**
   Деветата цифра (третата в серийния блок, индекс 8 ако броим от 0) казва пола: нечетна → мъж, четна → жена.

---

# Малък пример с изчисление (демонстрация на checksum)

ЕГН: `850315001?` (търсим последната цифра)

Първите 9 цифри: `8 5 0 3 1 5 0 0 1`
Тегла:             `2 4 8 5 10 9 7 3 6`

Произведения по позиции (стъпка по стъпка):

* 8×2 = 16
* 5×4 = 20  → сума 36
* 0×8 = 0   → сума 36
* 3×5 = 15  → сума 51
* 1×10 = 10 → сума 61
* 5×9 = 45  → сума 106
* 0×7 = 0   → сума 106
* 0×3 = 0   → сума 106
* 1×6 = 6   → сума 112

112 % 11 = 2 → контролна цифра = 2 (тъй като остатъкът не е 10).
Следователно валидното ЕГН е `8503150012`.

---

# Бележки и практични съвети

* Функцията проверява само формално и логически (дата и контролна цифра). Ако имате нужда от проверка срещу регистър/БДС/служба, това е отделна операция (извън локалната проверка).
* При вход с водещи/крайни интервали се прави `trim()`. Ако очаквате числа (int), винаги работете с низ, защото водещите нули са важни.
* `parseEGN()` връща false при невалидно ЕГН; при валидно дава дата в ISO формат, пол, серийния номер и контролна цифра.

Ако искаш, мога да:

* добавя логове/съобщения за причината за невалидността (напр. „грешен формат“, „недопустим месец“, „контролна цифра не съвпада“),
* или да ти дам примерен unit test (PHPUnit) за тестване на функцията.

